[
  {
    "name": "Game Master Tabletop RPG Note Taking",
    "shortName": "gamemaster",
    "description": "Write notes in markdown and connect related entities to always find the note that you need.",
    "projectUrl": "https://game-master-remix-client.pages.dev",
    "githubUrl": "https://github.com/Callumk7/game-master",
    "coverImageUrl": "http://image.com",
    "tags": [
      "react",
      "remix",
      "cloudflare",
      "turso",
      "typescript",
      "react-aria-components"
    ],
    "caseStudyUrl": null,
    "content": "<p>Game Master is a note-taking app aimed at table-top role playing game players. I wanted to provide a platform that provided a clean and simple note taking experience, with an opinionated strategy for note taking for gaming, as well as both an editor client and a wiki-like read-only experience for players.</p>\n<p>I built the initial prototype of the editor and backend using a few technologies that I was excited to try out. These included:</p>\n<ul>\n<li>Cloudflare pages and workers</li>\n<li>TursoDB</li>\n<li>React Aria Components</li>\n</ul>\n<p>As I was going to be working on this project solo, I was drawn to the idea of serverless deployment targets, as they offload many traditional dev ops burdens such as load management and scaling up and down based on traffic. In addition, nearly all full stack frameworks these days have nice integrations into the serverless platforms, so I can enjoy features like automatic deployments from git commits, and easy roll back to stable releases. I went for <strong>Cloudflare</strong> because I had already toyed with cloudflare workers in the past and enjoyed the experience, and they have recently been releasing some cool stuff like D2 databases, KV stores, and nice, easy to use APIs for open source AI LLMs.</p>\n<p><strong>Turso</strong>  was a product I was interested in trying out alongside this, as it was intially selling itself as a kind of serverless database solution. Whilst that messaging has changed, they are essentially a distributed and easily replicatable SQLite database that can be interacted with through a client, or your ORM of choice. As I was going to be deploying serverless for my prototype, it seemed a good time to try them out, especially considering the generous free tier.</p>\n<p>Finally, I have lots of experience with Radix UI as a headless accessible component library for react, and I wanted to try out an alternative in the headless UI space. React Aria Components is an open source project by Adobe, and so the long term backing makes it an attractive library. The collections API is very interesting, and I was excited to see how it compared to Radix.</p>\n<h1>Prototype App</h1>\n<p>The prototype app (see the <code>prototype</code> branch in <a href=\"https://github.com/Callumk7/game-master\">the repo</a> for the code, or the visit the <a href=\"https://game-master-remix-client.pages.dev\">deployment on cloudflare</a>)</p>\n<h1>Current Version</h1>\n<p>After learning a lot about adobe's components, I re-wrote the product to utilise a node backend to handle all database interactions, and then an 'API' package that wraps my HTTP requests into a nice sdk that I can use in both the remix editor app, the wiki app, and anywhere else I might need it.</p>\n<h2>End to End Type Safety</h2>\n<p>I love typescript, and being able to have type-safe http requests inside the client is a huge productivity boost. In order to achieve that though, it is critical to have a single source of truth between client what the client is expecting to recieve, and what the server is sending. By ensuring that that contract is handled in a separate package, I can achieve this whilst reducing runtime validation to the smallest amount required.</p>\n<h3>Setup</h3>\n<p>The <code>API</code> package exports both the client api class, which has all the request methods organised by resource, as well as my zod schemas and entity types that can be used on both the client and the server. The schemas are used to validate the requests on the server, and the <code>RequestBody</code> inferred types are used on the client to ensure that the client is sending the correct data at build-time, saving runtime validation costs.</p>\n<div data-callout data-callout-type=\"note\">\n<div data-callout-title>Working with Hono</div>\n<div data-callout-body>\n<p>Ideally, I would have liked to use a traditional typing strategy for my handlers in hono. In typescript (and most statically typed languages), we write functions like:</p>\n<pre class=\"shiki houston\" style=\"background-color:#17191e;color:#eef0f9\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#54B9FF\">function</span><span style=\"color:#00DAEF\"> functionName</span><span style=\"color:#EEF0F9\">(</span><span style=\"color:#4BF3C8;font-style:italic\">arg</span><span style=\"color:#EEF0F9\">: </span><span style=\"color:#ACAFFF\">TypeOne</span><span style=\"color:#EEF0F9\">): </span><span style=\"color:#ACAFFF\">TypeTwo</span><span style=\"color:#EEF0F9\"> {</span></span>\n<span class=\"line\"><span style=\"color:#EEF0F98F;font-style:italic\">  //...</span></span>\n<span class=\"line\"><span style=\"color:#EEF0F9\">}</span></span>\n<span class=\"line\"></span></code></pre>\n<p>The type annotation for the return means that we will get an error if we return anything else. Using hono though, we can't use our package types for this purpose, as we must return a <code>Response</code>.\nInstead, I chose to ensure that all the data sent back with <code>c.json(data)</code> was of the required type.</p>\n</div>\n</div>\n<h3>Client side</h3>\n<p>The advantage of writing the client like this means that we have a single <code>api</code> class that we can use for all our fetches. This can happen on the remix backend (first choice, for SSR and waterfall-reduction), or the client itself inside the react app. It also means that I can use the same package for the wiki app, vastly simplifying the development process there.</p>",
    "slug": "game-master-tabletop-rpg-note-taking",
    "tech": [
      "react",
      "turso",
      "remix",
      "cloudflare",
      "typescript"
    ],
    "wip": false,
    "cvDescription": "In order to learn the accessible component library from adobe, I created this project to combine various principles such as optimistic updates, serverless environments and monorepos.",
    "screenshotCount": 5
  },
  {
    "name": "playQ Videogame Playlist Manager",
    "shortName": "playq",
    "description": "Create and share playlists to keep track of what you have been playing",
    "projectUrl": "https://playq.xyz",
    "githubUrl": "https://github.com/Callumk7/frontline-v2-remix",
    "coverImageUrl": "http://image.com",
    "tags": [
      "react",
      "remix",
      "supabase",
      "typescript",
      "flydotio"
    ],
    "caseStudyUrl": "/blog/introducing-playq-a-cuttingedge-videogame-playlist-manager",
    "content": "<p>I built <strong>playQ</strong>, a complex CRUD application designed to manage video game collections and playlists. The application leverages modern web technologies to provide a seamless user experience for managing and exploring video games.</p>\n<p><strong>Features</strong></p>\n<ul>\n<li><strong>User Authentication</strong>: Secure user login and registration powered by Supabase.</li>\n<li><strong>Database Search and Filtering</strong>: Efficient search functionality to find games in the database.</li>\n<li><strong>Personal Collections</strong>: Save and organise games into personal collections.</li>\n<li><strong>Playlists</strong>: Create, edit, and manage playlists of games.</li>\n<li><strong>Social Features</strong>: Find and follow other users, track their playlists, and see their game progress.</li>\n<li><strong>Activity Feed</strong>: Highlights key activities of friends.</li>\n<li><strong>Comment System</strong>: Comment on games, playlists, and user profiles.</li>\n<li><strong>Game Discovery</strong>: Explore games based on popularity and user ratings.</li>\n<li><strong>Media Integration</strong>: Video game artwork and screenshots provided by IGDB.</li>\n</ul>\n<p><strong>Technology Used</strong></p>\n<p><strong>Supabase</strong>\nSupabase is utilised for authentication and database management. It offers real-time subscriptions and auto-generated APIs, providing the versatility of PostgreSQL while replicating some Firebase features.</p>\n<p><strong>Remix and React</strong>\nThe UI, routing, and data loading are built with Remix and React. Remix enhances user experience with server-side rendering on initial load and efficient data fetching for client-side navigation.</p>\n<p><strong>DrizzleORM</strong>\nDrizzleORM handles the app's Object-Relational Mapping (ORM). It simplifies data operations like inserting, updating, or querying data, and provides robust tools for managing database schema migrations.</p>\n<p><strong>Radix-UI and Shadcn Inspired Components</strong>\nThe app uses Radix-UI for low-level, accessible, and unstyled UI components, offering a developer-friendly declarative API. The UI design is influenced by Shadcn styled-components, promoting a modern and minimalist aesthetic.</p>\n<p><strong>Tailwind CSS</strong>\nTailwind CSS is used for atomic styling with utility classes. It integrates well with Radix and can be combined with conditional class libraries like clsx and class-variance-authority to rapidly build expressive design systems.</p>\n<p><a href=\"http://Fly.io\"><strong>Fly.io</strong></a>\nThe application is deployed on <a href=\"http://Fly.io\">Fly.io</a>, chosen for its easy deployment, scalability, and serverful runtime, which fully utilises Node.js's capabilities.</p>\n<p><strong>Cloudflare Workers</strong>\nServerless functions are employed for asynchronous tasks. A custom API accessed via a Cloudflare Worker offloads large writes to the database, ensuring smooth user flow when saving game data.</p>",
    "slug": "playq-videogame-playlist-manager",
    "tech": [
      "react",
      "postgres",
      "remix",
      "supabase",
      "nodejs",
      "typescript",
      "cloudflare"
    ],
    "wip": false,
    "cvDescription": "I built a playlist management solution that supports server side rendering (SSR), user authentication, aggregated scores and ratings, and a user activity feed. The app uses React and Remix as the full stack framework, with some additional asyncronous tasks offloaded to a cloudflare application.",
    "screenshotCount": 3
  },
  {
    "name": "My Developer Portfolio",
    "shortName": "portfolio",
    "description": "This website! A space to showcase my completed and in-progress projects, host my blog, and share my photography",
    "projectUrl": "https://callum.kloos.com",
    "githubUrl": "https://github.com/Callumk7/callum-blog-remix",
    "coverImageUrl": "http://image.com",
    "tags": [
      "react",
      "remix"
    ],
    "caseStudyUrl": "link to article on this project",
    "content": "<p>As a self-taught web developer, I needed a space to showcase my projects and skills to the world. I built this site to do just that.</p>\n<p>The site itself is built with the Remix framework (my full stack framework of choice), and all the code is available open source on Github.</p>\n<p>I opted for a clean, modern design. I want to keep things simple, and make sure that the content is front and centre. For more thoughts on the design, see my introduction blog post.</p>\n<p>I built a custom pipeline for building a JSON data schema from markdown blog posts using <code>matter</code> and <code>remark</code>. This means I have no external dependencies or database ORM to worry about, and all my inputs are fully typed with Typescript.</p>\n<p>Please enjoy exploring, and send me a message with any thoughts that you have.</p>",
    "slug": "my-developer-portfolio",
    "tech": [
      "react",
      "remix",
      "typescript"
    ],
    "wip": false,
    "cvDescription": "I built an entirely custom portfolio website using React and Remix. I wrote a custom build process which parses markdown content and caches the output into simple JSON for the app to consume on request with response times of less than 7ms.",
    "screenshotCount": 3
  },
  {
    "name": "ReCollect Social Journalling",
    "shortName": "recollect",
    "description": "Build a habit, remember together",
    "projectUrl": "https://recollect.dev",
    "githubUrl": "https://github.com/Callumk7/frontline-v2-remix",
    "coverImageUrl": "http://image.com",
    "tags": [
      "react",
      "remix",
      "cloudflare",
      "supabase",
      "typescript"
    ],
    "caseStudyUrl": "/blog/introducing-playq-a-cuttingedge-videogame-playlist-manager",
    "content": "<h2>Introduction to playQ</h2>\n<p>PlayQ is a game management application that allows users to create and track lists of video games, known as playlists. It provides a comprehensive platform for users to keep track of games they've played, want to play, or are currently playing.</p>\n<p>Moreover, you can rate the games on a personal scale, adding another layer of information to your lists. This functionality also allows for a comparative analysis between different games based on user ratings.</p>\n<p>This app promotes social interaction by allowing users to share their game playlists with friends or publicly. This makes it easier for users to discover new games and understand their friends' gaming preferences. PlayQ aims to facilitate easier decision-making when it comes to choosing the next game to play.</p>\n<h2>playQ - A Learning Project</h2>\n<p>PlayQ is not just a game playlist management app, it's also a comprehensive learning project that incorporates a variety of advanced technologies:</p>\n<p><strong>Supabase</strong> - PlayQ uses Supabase for authentication and database management. Supabase is an open-source Firebase alternative that replicates some of its features like real-time subscriptions and auto-generated APIs, while offering the versatility of PostgreSQL.</p>\n<p><strong>Remix and React</strong> - The user interface (UI), routing, and data loading are built with Remix and React. Remix is a powerful web framework for React that priorities user experience, while React facilitates building reusable UI components efficiently.</p>\n<p><strong>DrizzleORM</strong> - The app's Object-Relational Mapping (ORM) is handled by DrizzleORM. With DrizzleORM, JavaScript objects are mapped to database tables, simplifying data operations like inserting, updating, or querying data.</p>\n<p><strong>Radix-UI and Shad/cn Inspired Components</strong> - To further refine the user interface, the app uses Radix-UI, a library of low-level, accessible and unstyled UI components for building high-quality web interfaces. The UI design is also influenced by ShaD/CN styled-components, favouring a modern and minimalist aesthetic.</p>\n<p>By using these technologies, PlayQ showcases how sophisticated tech stacks can be combined for efficient coding practices and superior user experience.</p>\n<h2>Database Design</h2>\n<p>![[Database design.svg]]\nUtilised a many to many database design to enable many key features of the collection manager.</p>",
    "slug": "recollect-social-journalling",
    "tech": [
      "react",
      "postgres",
      "remix",
      "supabase",
      "nodejs",
      "typescript",
      "cloudflare"
    ],
    "wip": true
  },
  {
    "name": "Spotify Shared Playlists",
    "shortName": "spotifysharedplaylists",
    "description": "A weekend project that allows friends to create joint playlists, that can be easily filtered to create playback vibes. Useful for sharing who you are interested in seeing at festivals.",
    "projectUrl": "https://spotify-playlists-bs5.pages.dev",
    "githubUrl": "https://github.com/Callumk7/spotify-playlists",
    "coverImageUrl": "http://image.com",
    "tags": [
      "cloudflare",
      "remix"
    ],
    "caseStudyUrl": "link to article on this project",
    "content": "<p>A weekend project experimenting with</p>\n<ol>\n<li>using an external oAuth flow for user authentication via cookies</li>\n<li>using cloudflare and d1 for a serverless deployment</li>\n<li>vite as a bundler for remix apps</li>\n<li>caching using cloudflare kv</li>\n</ol>",
    "slug": "spotify-shared-playlists",
    "tech": [
      "cloudflare",
      "remix",
      "d1"
    ],
    "wip": true,
    "cvDescription": "A weekend project that allows friends to create joint playlists, that can be easily filtered to create playback vibes. Useful for sharing who you are interested in seeing at festivals."
  },
  {
    "name": "This Little Piggy Richmond",
    "shortName": "thislittlepiggyrichmond",
    "description": "Animal Rescue Charity focusing on Guinea Pigs",
    "projectUrl": "https://thislittlepiggyrichmond.co.uk",
    "githubUrl": "https://github.com/Callumk7/my-little-piggy-homepage",
    "coverImageUrl": "http://image.com",
    "tags": [
      "react",
      "ssr",
      "nextjs"
    ],
    "caseStudyUrl": "link to article on this project",
    "content": "<p><strong>This Little Piggy Richmond</strong> is a local charity dedicated to the rescue and rehoming of vulnerable guinea pigs throughout London and beyond. They operate a responsible rehoming scheme, ensuring that each guinea pig is placed in a safe, sustainable environment.</p>\n<h2>Need</h2>\n<p>The organisation approached us, seeking a website with excellent SEO performance and discoverability within their specific sector. An essential requirement was the provision of an online platform where potential adopters could view recently rescued guinea pigs, including those that need companionship due to their social nature. The guarantor required this site to be dynamic, user-friendly and capable of frequent updates, as changes were anticipated multiple times a week. Additionally, it was critical that the site be fully responsive and accessible.</p>\n<h3>Solution</h3>\n<p>Due to the client's non-technical background, we aimed to integrate a user-friendly, no-code solution to serve as the data source for the new application. We contemplated using a purpose-built CMS. However, upon careful deliberation, it was clear that such a solution might bring unnecessary complexity and a surplus of features. Thus, we chose to utilise a simple Notion database; it offers a comprehensive API allowing both writing and access to data, adequately fulfilling the identified needs.</p>\n<h3>Dynamic Data</h3>\n<p>For the web application to remain relevant and timely, it was crucial to facilitate dynamic data representation, updated at the point of request. Therefore, a server-side rendering approach was more suitable than a built-dependent statically generated approach, although the latter might have been more performant.</p>\n<h2>Technology Used</h2>\n<table>\n<thead>\n<tr>\n<th>Requirement</th>\n<th>Selection</th>\n<th>Justification</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Front-end Framework</td>\n<td>Next.js</td>\n<td>Flexible with rendering options, allows for future scalability</td>\n</tr>\n<tr>\n<td>Database</td>\n<td>Notion</td>\n<td>User-friendly interface, enabling rapid development by bypassing the need for a separate admin panel</td>\n</tr>\n<tr>\n<td>Hosting</td>\n<td>Vercel</td>\n<td>Tightly integrated with Next.js, offering a free-tier that aligns with the client's expected usage</td>\n</tr>\n</tbody>\n</table>\n<h2>Conclusion</h2>\n<p>In conclusion, the successful implementation of this project not only provided a significant online presence for 'This Little Piggy Richmond' but also met the specific requirements of the client with precision. Leveraging the user-friendly interface of Notion and the flexibility of Next.js, we were able to create a dynamic, accessible, and easy-to-update platform. This accomplishment empowers the organisation to continue their noble cause of rescuing and rehoming guinea pigs seamlessly. Furthermore, the selection of technologies underpins the siteâ€™s sustainability, ensuring scalability to match the organisation's future growth.</p>",
    "slug": "this-little-piggy-richmond",
    "tech": [
      "react",
      "nextjs",
      "notion"
    ],
    "wip": false,
    "cvDescription": "I built a client-facing website that utilises Notion as a backend to facilitate dynamic content updates without the need for a complex CMS solution. Data on the inventory can be changed by the client and seen instantly without a build step. Built with Next.js and deployed to Vercel.",
    "screenshotCount": 3
  }
]